import { Immersion } from '../schemas.js';
import { IMMERSION_TYPES, AI_MODULES } from '../constants.js';
import { IMMERSION_EVENTS } from '../hooks/index.js';
import mongoose from 'mongoose';

/**
 * Business logic for the Immersion module
 */
export const initActions = (ctx) => {
  const { eventBus, logger } = ctx;
  const log = logger.child({ module: 'immersion-actions' });
  
  return {
    /**
     * Create a new immersion experience
     */
    async createImmersion(immersionData, userId) {
      try {
        // Basic validation
        if (!immersionData.title) {
          throw new Error('Immersion title is required');
        }
        
        if (!immersionData.type || !Object.values(IMMERSION_TYPES).includes(immersionData.type)) {
          throw new Error('Invalid immersion type');
        }
        
        // Set default values
        const now = new Date();
        const newImmersion = new Immersion({
          ...immersionData,
          userId,
          createdAt: now,
          updatedAt: now,
          engagementMetrics: {
            completionRate: 0,
            averageSessionTime: 0,
            userRatings: [],
            revisitRate: 0,
            shareCount: 0,
            effectivenessScore: 0,
            completedCount: 0,
            startedCount: 0
          }
        });
        
        // Save the immersion
        const savedImmersion = await newImmersion.save();
        
        // Emit creation event
        eventBus.emit(IMMERSION_EVENTS.CREATED, {
          immersion: savedImmersion,
          userId
        });
        
        log.info(`Created new immersion "${savedImmersion.title}" (${savedImmersion._id}) for user ${userId}`);
        return savedImmersion;
      } catch (error) {
        log.error(`Failed to create immersion: ${error.message}`, { error });
        throw error;
      }
    },
    
    /**
     * Generate an immersion experience using AI
     */
    async generateImmersion(params, userId) {
      try {
        const { title, type, prompt, aiModule = AI_MODULES.TEXT_GENERATION } = params;
        
        // Check if AI service is available
        if (!ctx.services || !ctx.services.ai) {
          throw new Error('AI service not available');
        }
        
        // Basic validation
        if (!title) {
          throw new Error('Title is required for AI-generated immersion');
        }
        
        if (!type || !Object.values(IMMERSION_TYPES).includes(type)) {
          throw new Error('Valid immersion type is required');
        }
        
        if (!prompt) {
          throw new Error('AI prompt is required');
        }
        
        // Generate content based on type and prompt
        log.info(`Generating ${type} immersion content with AI module: ${aiModule}`);
        
        const generatedContent = await ctx.services.ai.generateContent({
          prompt,
          type,
          module: aiModule
        });
        
        if (!generatedContent || !generatedContent.content) {
          throw new Error('Failed to generate content from AI');
        }
        
        // Create the immersion with generated content
        const immersionData = {
          title,
          type,
          content: generatedContent.content,
          structuredContent: generatedContent.structuredContent || null,
          isGeneratedByAI: true,
          aiModuleUsed: aiModule,
          aiPromptUsed: prompt,
          metadata: {
            ...(params.metadata || {}),
            recommendedDuration: generatedContent.recommendedDuration || params.metadata?.recommendedDuration || 10
          }
        };
        
        // Add any media generated by AI
        if (generatedContent.media && generatedContent.media.length > 0) {
          immersionData.media = generatedContent.media.map(item => ({
            ...item,
            isGeneratedByAI: true,
            aiPromptUsed: item.aiPromptUsed || prompt
          }));
        }
        
        // Create the immersion
        return await this.createImmersion(immersionData, userId);
      } catch (error) {
        log.error(`Failed to generate immersion with AI: ${error.message}`, { error });
        throw error;
      }
    },
    
    /**
     * Start an immersion session for a user
     */
    async startImmersionSession(immersionId, userId) {
      try {
        // Find the immersion
        const immersion = await Immersion.findById(immersionId);
        if (!immersion) {
          throw new Error(`Immersion not found: ${immersionId}`);
        }
        
        // Check if user has an existing progress record
        const existingProgress = immersion.userProgress?.find(p => 
          p.userId.toString() === userId.toString()
        );
        
        const startTime = new Date();
        
        if (existingProgress) {
          // Update the existing progress
          await Immersion.updateOne(
            { 
              _id: immersionId,
              'userProgress.userId': userId 
            },
            { 
              $set: {
                'userProgress.$.startedAt': startTime,
                'userProgress.$.isCompleted': false 
              },
              $push: {
                'userProgress.$.sessionDurations': {
                  startTime,
                  endTime: null
                }
              }
            }
          );
        } else {
          // Create a new progress record
          await Immersion.updateOne(
            { _id: immersionId },
            {
              $push: {
                userProgress: {
                  userId,
                  startedAt: startTime,
                  completedAt: null,
                  isCompleted: false,
                  sessionDurations: [{
                    startTime,
                    endTime: null
                  }],
                  rating: null,
                  feedback: null,
                  effectiveness: null,
                  notes: []
                }
              }
            }
          );
        }
        
        // Emit started event
        eventBus.emit(IMMERSION_EVENTS.STARTED, {
          immersionId,
          userId,
          startTime
        });
        
        log.info(`User ${userId} started immersion ${immersionId}`);
        return { success: true, startTime };
      } catch (error) {
        log.error(`Failed to start immersion session: ${error.message}`, { error });
        throw error;
      }
    },
    
    /**
     * Complete an immersion session for a user
     */
    async completeImmersionSession(immersionId, userId, data = {}) {
      try {
        const { rating, feedback, effectiveness, sessionNotes } = data;
        const completionTime = new Date();
        
        // Find the immersion
        const immersion = await Immersion.findById(immersionId);
        if (!immersion) {
          throw new Error(`Immersion not found: ${immersionId}`);
        }
        
        // Calculate session duration if possible
        let sessionDuration = null;
        const userProgressIndex = immersion.userProgress?.findIndex(p => 
          p.userId.toString() === userId.toString()
        );
        
        if (userProgressIndex === -1) {
          throw new Error(`User ${userId} has not started this immersion`);
        }
        
        const userProgress = immersion.userProgress[userProgressIndex];
        const lastSessionIndex = userProgress.sessionDurations.length - 1;
        
        if (lastSessionIndex >= 0 && userProgress.sessionDurations[lastSessionIndex].startTime) {
          const startTime = new Date(userProgress.sessionDurations[lastSessionIndex].startTime);
          sessionDuration = (completionTime - startTime) / (1000 * 60); // Convert to minutes
        }
        
        // Update the user progress
        const updateData = {
          [`userProgress.${userProgressIndex}.completedAt`]: completionTime,
          [`userProgress.${userProgressIndex}.isCompleted`]: true
        };
        
        // Update the last session's end time
        if (lastSessionIndex >= 0) {
          updateData[`userProgress.${userProgressIndex}.sessionDurations.${lastSessionIndex}.endTime`] = completionTime;
        }
        
        // Add optional feedback data
        if (rating !== undefined) {
          updateData[`userProgress.${userProgressIndex}.rating`] = rating;
        }
        
        if (feedback) {
          updateData[`userProgress.${userProgressIndex}.feedback`] = feedback;
        }
        
        if (effectiveness !== undefined) {
          updateData[`userProgress.${userProgressIndex}.effectiveness`] = effectiveness;
        }
        
        if (sessionNotes) {
          updateData[`userProgress.${userProgressIndex}.notes`] = Array.isArray(sessionNotes) ? 
            sessionNotes : [sessionNotes];
        }
        
        await Immersion.updateOne(
          { _id: immersionId },
          { $set: updateData }
        );
        
        // Emit completed event
        eventBus.emit(IMMERSION_EVENTS.COMPLETED, {
          immersionId,
          userId,
          completionTime,
          sessionTime: sessionDuration,
          rating
        });
        
        log.info(`User ${userId} completed immersion ${immersionId}`, { 
          sessionDuration, 
          rating: rating || 'not provided' 
        });
        
        return { 
          success: true, 
          completionTime,
          sessionDuration
        };
      } catch (error) {
        log.error(`Failed to complete immersion session: ${error.message}`, { error });
        throw error;
      }
    },
    
    /**
     * Link an immersion to a manifestation
     */
    async linkToManifestation(immersionId, manifestationId, userId) {
      try {
        // Verify the immersion exists and user has access
        const immersion = await Immersion.findOne({ _id: immersionId });
        if (!immersion) {
          throw new Error(`Immersion not found: ${immersionId}`);
        }
        
        // If this is a private immersion, check ownership
        if (immersion.metadata?.isPublic === false && immersion.userId.toString() !== userId.toString()) {
          throw new Error('You do not have permission to link this immersion');
        }
        
        // If Manifestation model is available, verify it exists
        if (ctx.models && ctx.models.Manifestation) {
          const Manifestation = mongoose.model('Manifestation');
          const manifestation = await Manifestation.findOne({ 
            _id: manifestationId,
            userId
          });
          
          if (!manifestation) {
            throw new Error(`Manifestation not found or access denied: ${manifestationId}`);
          }
        }
        
        // Link the immersion to the manifestation
        await Immersion.updateOne(
          { _id: immersionId },
          { $addToSet: { relatedManifestations: manifestationId } }
        );
        
        // Emit link event
        eventBus.emit(IMMERSION_EVENTS.LINKED_TO_MANIFESTATION, {
          immersionId,
          manifestationId,
          userId
        });
        
        log.info(`Linked immersion ${immersionId} to manifestation ${manifestationId}`);
        return { success: true };
      } catch (error) {
        log.error(`Failed to link immersion to manifestation: ${error.message}`, { error });
        throw error;
      }
    },
    
    /**
     * Get recommended immersions for a user
     */
    async getRecommendedImmersions(userId, options = {}) {
      try {
        const { limit = 5, type = null, lifeAreas = [] } = options;
        
        // Create a base query
        const query = { 'metadata.isPublic': true };
        
        // Filter by type if specified
        if (type && Object.values(IMMERSION_TYPES).includes(type)) {
          query.type = type;
        }
        
        // Filter by life areas if specified
        if (lifeAreas && lifeAreas.length > 0) {
          query['metadata.lifeAreas'] = { $in: lifeAreas };
        }
        
        // Get completed immersions by this user
        const userCompletedImmersions = await Immersion.find({
          userProgress: {
            $elemMatch: {
              userId,
              isCompleted: true
            }
          }
        }).select('_id type metadata.lifeAreas');
        
        // Skip already completed immersions if there are enough alternatives
        const completedIds = userCompletedImmersions.map(i => i._id);
        const totalCount = await Immersion.countDocuments(query);
        
        if (totalCount > limit * 2 && completedIds.length > 0) {
          query._id = { $nin: completedIds };
        }
        
        // Find high-rated immersions for recommendation
        const recommendedImmersions = await Immersion.find(query)
          .sort({ 
            'engagementMetrics.userRatings': -1, 
            'engagementMetrics.completionRate': -1 
          })
          .limit(limit);
        
        // If we don't have enough recommendations, include some the user has already completed
        if (recommendedImmersions.length < limit && completedIds.length > 0) {
          const remainingLimit = limit - recommendedImmersions.length;
          const additionalImmersions = await Immersion.find({ _id: { $in: completedIds } })
            .sort({ 'engagementMetrics.effectivenessScore': -1 })
            .limit(remainingLimit);
          
          recommendedImmersions.push(...additionalImmersions);
        }
        
        return recommendedImmersions;
      } catch (error) {
        log.error(`Failed to get recommended immersions: ${error.message}`, { error });
        throw error;
      }
    }
  };
};

export default initActions; 